"use strict";Object.defineProperty(exports, "__esModule", {value: true});"use client";


var _I62GZSMKcjs = require('./I62GZSMK.cjs');



var _OZFFK5VScjs = require('./OZFFK5VS.cjs');


var _OR7WTDA4cjs = require('./OR7WTDA4.cjs');


var _DYEW6UIBcjs = require('./DYEW6UIB.cjs');


var _VYTT2R6Pcjs = require('./VYTT2R6P.cjs');


var _6IUEXB4Lcjs = require('./6IUEXB4L.cjs');


var _JF225FQ5cjs = require('./JF225FQ5.cjs');



var _MUQXBDURcjs = require('./MUQXBDUR.cjs');


var _OVBWMHNOcjs = require('./OVBWMHNO.cjs');


var _W3DXC3KCcjs = require('./W3DXC3KC.cjs');


var _FAFAXYUEcjs = require('./FAFAXYUE.cjs');


var _TGMTQMEKcjs = require('./TGMTQMEK.cjs');



var _SY7NHEDFcjs = require('./SY7NHEDF.cjs');





var _CQ3ILEKOcjs = require('./CQ3ILEKO.cjs');


var _EDR5S5CXcjs = require('./EDR5S5CX.cjs');




var _AWEKOM65cjs = require('./AWEKOM65.cjs');


var _7D3WLJ6Ycjs = require('./7D3WLJ6Y.cjs');


var _PULY27HQcjs = require('./PULY27HQ.cjs');








var _OUWHJLQHcjs = require('./OUWHJLQH.cjs');




var _3IVNQNIVcjs = require('./3IVNQNIV.cjs');

// src/dialog/dialog.tsx





var _dom = require('@ariakit/core/utils/dom');



var _events = require('@ariakit/core/utils/events');




var _focus = require('@ariakit/core/utils/focus');
var _misc = require('@ariakit/core/utils/misc');
var _platform = require('@ariakit/core/utils/platform');
var _react = require('react');
var _jsxruntime = require('react/jsx-runtime');
var TagName = "div";
var isSafariBrowser = _platform.isSafari.call(void 0, );
function isAlreadyFocusingAnotherElement(dialog) {
  const activeElement = _dom.getActiveElement.call(void 0, );
  if (!activeElement) return false;
  if (dialog && _dom.contains.call(void 0, dialog, activeElement)) return false;
  if (_focus.isFocusable.call(void 0, activeElement)) return true;
  return false;
}
function getElementFromProp(prop, focusable = false) {
  if (!prop) return null;
  const element = "current" in prop ? prop.current : prop;
  if (!element) return null;
  if (focusable) return _focus.isFocusable.call(void 0, element) ? element : null;
  return element;
}
var useDialog = _AWEKOM65cjs.createHook.call(void 0, function useDialog2(_a) {
  var _b = _a, {
    store: storeProp,
    open: openProp,
    onClose,
    focusable = true,
    modal = true,
    portal = !!modal,
    backdrop = !!modal,
    hideOnEscape = true,
    hideOnInteractOutside = true,
    getPersistentElements,
    preventBodyScroll = !!modal,
    autoFocusOnShow = true,
    autoFocusOnHide = true,
    initialFocus,
    finalFocus,
    unmountOnHide,
    unstable_treeSnapshotKey
  } = _b, props = _3IVNQNIVcjs.__objRest.call(void 0, _b, [
    "store",
    "open",
    "onClose",
    "focusable",
    "modal",
    "portal",
    "backdrop",
    "hideOnEscape",
    "hideOnInteractOutside",
    "getPersistentElements",
    "preventBodyScroll",
    "autoFocusOnShow",
    "autoFocusOnHide",
    "initialFocus",
    "finalFocus",
    "unmountOnHide",
    "unstable_treeSnapshotKey"
  ]);
  const context = _CQ3ILEKOcjs.useDialogProviderContext.call(void 0, );
  const ref = _react.useRef.call(void 0, null);
  const store = _7D3WLJ6Ycjs.useDialogStore.call(void 0, {
    store: storeProp || context,
    open: openProp,
    setOpen(open2) {
      if (open2) return;
      const dialog = ref.current;
      if (!dialog) return;
      const event = new Event("close", { bubbles: false, cancelable: true });
      if (onClose) {
        dialog.addEventListener("close", onClose, { once: true });
      }
      dialog.dispatchEvent(event);
      if (!event.defaultPrevented) return;
      store.setOpen(true);
    }
  });
  const { portalRef, domReady } = _OUWHJLQHcjs.usePortalRef.call(void 0, portal, props.portalRef);
  const preserveTabOrderProp = props.preserveTabOrder;
  const preserveTabOrder = store.useState(
    (state) => preserveTabOrderProp && !modal && state.mounted
  );
  const id = _OUWHJLQHcjs.useId.call(void 0, props.id);
  const open = store.useState("open");
  const mounted = store.useState("mounted");
  const contentElement = store.useState("contentElement");
  const hidden = _SY7NHEDFcjs.isHidden.call(void 0, mounted, props.hidden, props.alwaysVisible);
  _OR7WTDA4cjs.usePreventBodyScroll.call(void 0, contentElement, id, preventBodyScroll && !hidden);
  _VYTT2R6Pcjs.useHideOnInteractOutside.call(void 0, store, hideOnInteractOutside, domReady);
  const { wrapElement, nestedDialogs } = _DYEW6UIBcjs.useNestedDialogs.call(void 0, store);
  props = _OUWHJLQHcjs.useWrapElement.call(void 0, props, wrapElement, [wrapElement]);
  _OUWHJLQHcjs.useSafeLayoutEffect.call(void 0, () => {
    if (!open) return;
    const dialog = ref.current;
    const activeElement = _dom.getActiveElement.call(void 0, dialog, true);
    if (!activeElement) return;
    if (activeElement.tagName === "BODY") return;
    if (dialog && _dom.contains.call(void 0, dialog, activeElement)) return;
    store.setDisclosureElement(activeElement);
  }, [store, open]);
  if (isSafariBrowser) {
    _react.useEffect.call(void 0, () => {
      if (!mounted) return;
      const { disclosureElement } = store.getState();
      if (!disclosureElement) return;
      if (!_dom.isButton.call(void 0, disclosureElement)) return;
      const onMouseDown = () => {
        let receivedFocus = false;
        const onFocus = () => {
          receivedFocus = true;
        };
        const options = { capture: true, once: true };
        disclosureElement.addEventListener("focusin", onFocus, options);
        _events.queueBeforeEvent.call(void 0, disclosureElement, "mouseup", () => {
          disclosureElement.removeEventListener("focusin", onFocus, true);
          if (receivedFocus) return;
          _focus.focusIfNeeded.call(void 0, disclosureElement);
        });
      };
      disclosureElement.addEventListener("mousedown", onMouseDown);
      return () => {
        disclosureElement.removeEventListener("mousedown", onMouseDown);
      };
    }, [store, mounted]);
  }
  _react.useEffect.call(void 0, () => {
    if (!modal) return;
    if (!mounted) return;
    if (!domReady) return;
    const dialog = ref.current;
    if (!dialog) return;
    const existingDismiss = dialog.querySelector("[data-dialog-dismiss]");
    if (existingDismiss) return;
    return _JF225FQ5cjs.prependHiddenDismiss.call(void 0, dialog, store.hide);
  }, [store, modal, mounted, domReady]);
  _OUWHJLQHcjs.useSafeLayoutEffect.call(void 0, () => {
    if (!_6IUEXB4Lcjs.supportsInert.call(void 0, )) return;
    if (open) return;
    if (!mounted) return;
    if (!domReady) return;
    const dialog = ref.current;
    if (!dialog) return;
    return _OZFFK5VScjs.disableTree.call(void 0, dialog);
  }, [open, mounted, domReady]);
  const canTakeTreeSnapshot = open && domReady;
  _OUWHJLQHcjs.useSafeLayoutEffect.call(void 0, () => {
    if (!id) return;
    if (!canTakeTreeSnapshot) return;
    const dialog = ref.current;
    return _OVBWMHNOcjs.createWalkTreeSnapshot.call(void 0, id, [dialog]);
  }, [id, canTakeTreeSnapshot, unstable_treeSnapshotKey]);
  const getPersistentElementsProp = _OUWHJLQHcjs.useEvent.call(void 0, getPersistentElements);
  _OUWHJLQHcjs.useSafeLayoutEffect.call(void 0, () => {
    if (!id) return;
    if (!canTakeTreeSnapshot) return;
    const { disclosureElement } = store.getState();
    const dialog = ref.current;
    const persistentElements = getPersistentElementsProp() || [];
    const allElements = [
      dialog,
      ...persistentElements,
      ...nestedDialogs.map((dialog2) => dialog2.getState().contentElement)
    ];
    if (modal) {
      return _misc.chain.call(void 0, 
        _MUQXBDURcjs.markTreeOutside.call(void 0, id, allElements),
        _OZFFK5VScjs.disableTreeOutside.call(void 0, id, allElements)
      );
    }
    return _MUQXBDURcjs.markTreeOutside.call(void 0, id, [disclosureElement, ...allElements]);
  }, [
    id,
    store,
    canTakeTreeSnapshot,
    getPersistentElementsProp,
    nestedDialogs,
    modal,
    unstable_treeSnapshotKey
  ]);
  const mayAutoFocusOnShow = !!autoFocusOnShow;
  const autoFocusOnShowProp = _OUWHJLQHcjs.useBooleanEvent.call(void 0, autoFocusOnShow);
  const [autoFocusEnabled, setAutoFocusEnabled] = _react.useState.call(void 0, false);
  _react.useEffect.call(void 0, () => {
    if (!open) return;
    if (!mayAutoFocusOnShow) return;
    if (!domReady) return;
    if (!(contentElement == null ? void 0 : contentElement.isConnected)) return;
    const element = getElementFromProp(initialFocus, true) || // If no initial focus is specified, we try to focus the first element
    // with the autofocus attribute. If it's an Ariakit component, the
    // Focusable component will consume the autoFocus prop and add the
    // data-autofocus attribute to the element instead.
    contentElement.querySelector(
      "[data-autofocus=true],[autofocus]"
    ) || // We have to fallback to the first focusable element otherwise portaled
    // dialogs with preserveTabOrder set to true will not receive focus
    // properly because the elements aren't tabbable until the dialog receives
    // focus.
    _focus.getFirstTabbableIn.call(void 0, contentElement, true, portal && preserveTabOrder) || // Finally, we fallback to the dialog element itself.
    contentElement;
    const isElementFocusable = _focus.isFocusable.call(void 0, element);
    if (!autoFocusOnShowProp(isElementFocusable ? element : null)) return;
    setAutoFocusEnabled(true);
    queueMicrotask(() => {
      element.focus();
      if (!isSafariBrowser) return;
      element.scrollIntoView({ block: "nearest", inline: "nearest" });
    });
  }, [
    open,
    mayAutoFocusOnShow,
    domReady,
    contentElement,
    initialFocus,
    portal,
    preserveTabOrder,
    autoFocusOnShowProp
  ]);
  const mayAutoFocusOnHide = !!autoFocusOnHide;
  const autoFocusOnHideProp = _OUWHJLQHcjs.useBooleanEvent.call(void 0, autoFocusOnHide);
  const [hasOpened, setHasOpened] = _react.useState.call(void 0, false);
  _react.useEffect.call(void 0, () => {
    if (!open) return;
    setHasOpened(true);
    return () => setHasOpened(false);
  }, [open]);
  const focusOnHide = _react.useCallback.call(void 0, 
    (dialog, retry = true) => {
      const { disclosureElement } = store.getState();
      if (isAlreadyFocusingAnotherElement(dialog)) return;
      let element = getElementFromProp(finalFocus) || disclosureElement;
      if (element == null ? void 0 : element.id) {
        const doc = _dom.getDocument.call(void 0, element);
        const selector = `[aria-activedescendant="${element.id}"]`;
        const composite = doc.querySelector(selector);
        if (composite) {
          element = composite;
        }
      }
      if (element && !_focus.isFocusable.call(void 0, element)) {
        const maybeParentDialog = element.closest("[data-dialog]");
        if (maybeParentDialog == null ? void 0 : maybeParentDialog.id) {
          const doc = _dom.getDocument.call(void 0, maybeParentDialog);
          const selector = `[aria-controls~="${maybeParentDialog.id}"]`;
          const control = doc.querySelector(selector);
          if (control) {
            element = control;
          }
        }
      }
      const isElementFocusable = element && _focus.isFocusable.call(void 0, element);
      if (!isElementFocusable && retry) {
        requestAnimationFrame(() => focusOnHide(dialog, false));
        return;
      }
      if (!autoFocusOnHideProp(isElementFocusable ? element : null)) return;
      if (!isElementFocusable) return;
      element == null ? void 0 : element.focus();
    },
    [store, finalFocus, autoFocusOnHideProp]
  );
  const focusedOnHideRef = _react.useRef.call(void 0, false);
  _OUWHJLQHcjs.useSafeLayoutEffect.call(void 0, () => {
    if (open) return;
    if (!hasOpened) return;
    if (!mayAutoFocusOnHide) return;
    const dialog = ref.current;
    focusedOnHideRef.current = true;
    focusOnHide(dialog);
  }, [open, hasOpened, domReady, mayAutoFocusOnHide, focusOnHide]);
  _react.useEffect.call(void 0, () => {
    if (!hasOpened) return;
    if (!mayAutoFocusOnHide) return;
    const dialog = ref.current;
    return () => {
      if (focusedOnHideRef.current) {
        focusedOnHideRef.current = false;
        return;
      }
      focusOnHide(dialog);
    };
  }, [hasOpened, mayAutoFocusOnHide, focusOnHide]);
  const hideOnEscapeProp = _OUWHJLQHcjs.useBooleanEvent.call(void 0, hideOnEscape);
  _react.useEffect.call(void 0, () => {
    if (!domReady) return;
    if (!mounted) return;
    const onKeyDown = (event) => {
      if (event.key !== "Escape") return;
      if (event.defaultPrevented) return;
      const dialog = ref.current;
      if (!dialog) return;
      if (_MUQXBDURcjs.isElementMarked.call(void 0, dialog)) return;
      const target = event.target;
      if (!target) return;
      const { disclosureElement } = store.getState();
      const isValidTarget = () => {
        if (target.tagName === "BODY") return true;
        if (_dom.contains.call(void 0, dialog, target)) return true;
        if (!disclosureElement) return true;
        if (_dom.contains.call(void 0, disclosureElement, target)) return true;
        return false;
      };
      if (!isValidTarget()) return;
      if (!hideOnEscapeProp(event)) return;
      store.hide();
    };
    return _events.addGlobalEventListener.call(void 0, "keydown", onKeyDown, true);
  }, [store, domReady, mounted, hideOnEscapeProp]);
  props = _OUWHJLQHcjs.useWrapElement.call(void 0, 
    props,
    (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _FAFAXYUEcjs.HeadingLevel, { level: modal ? 1 : void 0, children: element }),
    [modal]
  );
  const hiddenProp = props.hidden;
  const alwaysVisible = props.alwaysVisible;
  props = _OUWHJLQHcjs.useWrapElement.call(void 0, 
    props,
    (element) => {
      if (!backdrop) return element;
      return /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
        /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
          _I62GZSMKcjs.DialogBackdrop,
          {
            store,
            backdrop,
            hidden: hiddenProp,
            alwaysVisible
          }
        ),
        element
      ] });
    },
    [store, backdrop, hiddenProp, alwaysVisible]
  );
  const [headingId, setHeadingId] = _react.useState.call(void 0, );
  const [descriptionId, setDescriptionId] = _react.useState.call(void 0, );
  props = _OUWHJLQHcjs.useWrapElement.call(void 0, 
    props,
    (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _CQ3ILEKOcjs.DialogScopedContextProvider, { value: store, children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _CQ3ILEKOcjs.DialogHeadingContext.Provider, { value: setHeadingId, children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _CQ3ILEKOcjs.DialogDescriptionContext.Provider, { value: setDescriptionId, children: element }) }) }),
    [store]
  );
  props = _3IVNQNIVcjs.__spreadProps.call(void 0, _3IVNQNIVcjs.__spreadValues.call(void 0, {
    id,
    "data-dialog": "",
    role: "dialog",
    tabIndex: focusable ? -1 : void 0,
    "aria-labelledby": headingId,
    "aria-describedby": descriptionId
  }, props), {
    ref: _OUWHJLQHcjs.useMergeRefs.call(void 0, ref, props.ref)
  });
  props = _W3DXC3KCcjs.useFocusableContainer.call(void 0, _3IVNQNIVcjs.__spreadProps.call(void 0, _3IVNQNIVcjs.__spreadValues.call(void 0, {}, props), {
    autoFocusOnShow: autoFocusEnabled
  }));
  props = _SY7NHEDFcjs.useDisclosureContent.call(void 0, _3IVNQNIVcjs.__spreadValues.call(void 0, { store }, props));
  props = _EDR5S5CXcjs.useFocusable.call(void 0, _3IVNQNIVcjs.__spreadProps.call(void 0, _3IVNQNIVcjs.__spreadValues.call(void 0, {}, props), { focusable }));
  props = _TGMTQMEKcjs.usePortal.call(void 0, _3IVNQNIVcjs.__spreadProps.call(void 0, _3IVNQNIVcjs.__spreadValues.call(void 0, { portal }, props), { portalRef, preserveTabOrder }));
  return props;
});
function createDialogComponent(Component, useProviderContext = _CQ3ILEKOcjs.useDialogProviderContext) {
  return _AWEKOM65cjs.forwardRef.call(void 0, function DialogComponent(props) {
    const context = useProviderContext();
    const store = props.store || context;
    const mounted = _PULY27HQcjs.useStoreState.call(void 0, 
      store,
      (state) => !props.unmountOnHide || (state == null ? void 0 : state.mounted) || !!props.open
    );
    if (!mounted) return null;
    return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, Component, _3IVNQNIVcjs.__spreadValues.call(void 0, {}, props));
  });
}
var Dialog = createDialogComponent(
  _AWEKOM65cjs.forwardRef.call(void 0, function Dialog2(props) {
    const htmlProps = useDialog(props);
    return _AWEKOM65cjs.createElement.call(void 0, TagName, htmlProps);
  }),
  _CQ3ILEKOcjs.useDialogProviderContext
);





exports.useDialog = useDialog; exports.createDialogComponent = createDialogComponent; exports.Dialog = Dialog;
