"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.duplicateTemplatePartAction = exports.duplicatePatternAction = void 0;
exports.usePostActions = usePostActions;
var _icons = require("@wordpress/icons");
var _url = require("@wordpress/url");
var _data = require("@wordpress/data");
var _htmlEntities = require("@wordpress/html-entities");
var _coreData = require("@wordpress/core-data");
var _i18n = require("@wordpress/i18n");
var _notices = require("@wordpress/notices");
var _element = require("@wordpress/element");
var _patterns = require("@wordpress/patterns");
var _blocks = require("@wordpress/blocks");
var _dataviews = require("@wordpress/dataviews");
var _components = require("@wordpress/components");
var _constants = require("../../store/constants");
var _store = require("../../store");
var _lockUnlock = require("../../lock-unlock");
var _createTemplatePartModal = require("../create-template-part-modal");
var _utils = require("../../dataviews/actions/utils");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

// Patterns.
const {
  PATTERN_TYPES,
  CreatePatternModalContents,
  useDuplicatePatternProps
} = (0, _lockUnlock.unlock)(_patterns.privateApis);

// TODO: this should be shared with other components (see post-fields in edit-site).
const fields = [{
  type: 'text',
  id: 'title',
  label: (0, _i18n.__)('Title'),
  placeholder: (0, _i18n.__)('No title'),
  getValue: ({
    item
  }) => item.title
}, {
  type: 'integer',
  id: 'menu_order',
  label: (0, _i18n.__)('Order'),
  description: (0, _i18n.__)('Determines the order of pages.')
}];
const formDuplicateAction = {
  fields: ['title']
};
const formOrderAction = {
  fields: ['menu_order']
};

/**
 * Check if a template is removable.
 *
 * @param {Object} template The template entity to check.
 * @return {boolean} Whether the template is removable.
 */
function isTemplateRemovable(template) {
  if (!template) {
    return false;
  }
  // In patterns list page we map the templates parts to a different object
  // than the one returned from the endpoint. This is why we need to check for
  // two props whether is custom or has a theme file.
  return template?.source === _constants.TEMPLATE_ORIGINS.custom && !template?.has_theme_file;
}
const viewPostAction = {
  id: 'view-post',
  label: (0, _i18n.__)('View'),
  isPrimary: true,
  icon: _icons.external,
  isEligible(post) {
    return post.status !== 'trash';
  },
  callback(posts, {
    onActionPerformed
  }) {
    const post = posts[0];
    window.open(post.link, '_blank');
    if (onActionPerformed) {
      onActionPerformed(posts);
    }
  }
};
const postRevisionsAction = {
  id: 'view-post-revisions',
  context: 'list',
  label(items) {
    var _items$0$_links$versi;
    const revisionsCount = (_items$0$_links$versi = items[0]._links?.['version-history']?.[0]?.count) !== null && _items$0$_links$versi !== void 0 ? _items$0$_links$versi : 0;
    return (0, _i18n.sprintf)( /* translators: %s: number of revisions */
    (0, _i18n.__)('View revisions (%s)'), revisionsCount);
  },
  isEligible: post => {
    var _post$_links$predeces, _post$_links$version;
    if (post.status === 'trash') {
      return false;
    }
    const lastRevisionId = (_post$_links$predeces = post?._links?.['predecessor-version']?.[0]?.id) !== null && _post$_links$predeces !== void 0 ? _post$_links$predeces : null;
    const revisionsCount = (_post$_links$version = post?._links?.['version-history']?.[0]?.count) !== null && _post$_links$version !== void 0 ? _post$_links$version : 0;
    return lastRevisionId && revisionsCount > 1;
  },
  callback(posts, {
    onActionPerformed
  }) {
    const post = posts[0];
    const href = (0, _url.addQueryArgs)('revision.php', {
      revision: post?._links?.['predecessor-version']?.[0]?.id
    });
    document.location.href = href;
    if (onActionPerformed) {
      onActionPerformed(posts);
    }
  }
};
const renamePostAction = {
  id: 'rename-post',
  label: (0, _i18n.__)('Rename'),
  isEligible(post) {
    if (post.status === 'trash') {
      return false;
    }
    // Templates, template parts and patterns have special checks for renaming.
    if (![_constants.TEMPLATE_POST_TYPE, _constants.TEMPLATE_PART_POST_TYPE, ...Object.values(PATTERN_TYPES)].includes(post.type)) {
      return post.permissions?.update;
    }
    // In the case of templates, we can only rename custom templates.
    if (post.type === _constants.TEMPLATE_POST_TYPE) {
      return isTemplateRemovable(post) && post.is_custom && post.permissions?.update;
    }
    // Make necessary checks for template parts and patterns.
    const isTemplatePart = post.type === _constants.TEMPLATE_PART_POST_TYPE;
    const isUserPattern = post.type === PATTERN_TYPES.user;
    // In patterns list page we map the templates parts to a different object
    // than the one returned from the endpoint. This is why we need to check for
    // two props whether is custom or has a theme file.
    const isCustomPattern = isUserPattern || isTemplatePart && post.source === _constants.TEMPLATE_ORIGINS.custom;
    const hasThemeFile = post?.has_theme_file;
    return isCustomPattern && !hasThemeFile && post.permissions?.update;
  },
  RenderModal: ({
    items,
    closeModal,
    onActionPerformed
  }) => {
    const [item] = items;
    const [title, setTitle] = (0, _element.useState)(() => (0, _utils.getItemTitle)(item));
    const {
      editEntityRecord,
      saveEditedEntityRecord
    } = (0, _data.useDispatch)(_coreData.store);
    const {
      createSuccessNotice,
      createErrorNotice
    } = (0, _data.useDispatch)(_notices.store);
    async function onRename(event) {
      event.preventDefault();
      try {
        await editEntityRecord('postType', item.type, item.id, {
          title
        });
        // Update state before saving rerenders the list.
        setTitle('');
        closeModal();
        // Persist edited entity.
        await saveEditedEntityRecord('postType', item.type, item.id, {
          throwOnError: true
        });
        createSuccessNotice((0, _i18n.__)('Name updated'), {
          type: 'snackbar'
        });
        onActionPerformed?.(items);
      } catch (error) {
        const errorMessage = error.message && error.code !== 'unknown_error' ? error.message : (0, _i18n.__)('An error occurred while updating the name');
        createErrorNotice(errorMessage, {
          type: 'snackbar'
        });
      }
    }
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("form", {
      onSubmit: onRename,
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalVStack, {
        spacing: "5",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.TextControl, {
          __nextHasNoMarginBottom: true,
          __next40pxDefaultSize: true,
          label: (0, _i18n.__)('Name'),
          value: title,
          onChange: setTitle,
          required: true
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalHStack, {
          justify: "right",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Button, {
            __next40pxDefaultSize: true,
            variant: "tertiary",
            onClick: () => {
              closeModal();
            },
            children: (0, _i18n.__)('Cancel')
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Button, {
            __next40pxDefaultSize: true,
            variant: "primary",
            type: "submit",
            children: (0, _i18n.__)('Save')
          })]
        })]
      })
    });
  }
};
function ReorderModal({
  items,
  closeModal,
  onActionPerformed
}) {
  const [item, setItem] = (0, _element.useState)(items[0]);
  const orderInput = item.menu_order;
  const {
    editEntityRecord,
    saveEditedEntityRecord
  } = (0, _data.useDispatch)(_coreData.store);
  const {
    createSuccessNotice,
    createErrorNotice
  } = (0, _data.useDispatch)(_notices.store);
  async function onOrder(event) {
    event.preventDefault();
    if (!(0, _dataviews.isItemValid)(item, fields, formOrderAction)) {
      return;
    }
    try {
      await editEntityRecord('postType', item.type, item.id, {
        menu_order: orderInput
      });
      closeModal();
      // Persist edited entity.
      await saveEditedEntityRecord('postType', item.type, item.id, {
        throwOnError: true
      });
      createSuccessNotice((0, _i18n.__)('Order updated'), {
        type: 'snackbar'
      });
      onActionPerformed?.(items);
    } catch (error) {
      const errorMessage = error.message && error.code !== 'unknown_error' ? error.message : (0, _i18n.__)('An error occurred while updating the order');
      createErrorNotice(errorMessage, {
        type: 'snackbar'
      });
    }
  }
  const isSaveDisabled = !(0, _dataviews.isItemValid)(item, fields, formOrderAction);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("form", {
    onSubmit: onOrder,
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalVStack, {
      spacing: "5",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        children: (0, _i18n.__)('Determines the order of pages. Pages with the same order value are sorted alphabetically. Negative order values are supported.')
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_dataviews.DataForm, {
        data: item,
        fields: fields,
        form: formOrderAction,
        onChange: setItem
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalHStack, {
        justify: "right",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Button, {
          __next40pxDefaultSize: true,
          variant: "tertiary",
          onClick: () => {
            closeModal();
          },
          children: (0, _i18n.__)('Cancel')
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Button, {
          __next40pxDefaultSize: true,
          variant: "primary",
          type: "submit",
          accessibleWhenDisabled: true,
          disabled: isSaveDisabled,
          __experimentalIsFocusable: true,
          children: (0, _i18n.__)('Save')
        })]
      })]
    })
  });
}
function useReorderPagesAction(postType) {
  const supportsPageAttributes = (0, _data.useSelect)(select => {
    const {
      getPostType
    } = select(_coreData.store);
    const postTypeObject = getPostType(postType);
    return !!postTypeObject?.supports?.['page-attributes'];
  }, [postType]);
  return (0, _element.useMemo)(() => supportsPageAttributes && {
    id: 'order-pages',
    label: (0, _i18n.__)('Order'),
    isEligible({
      status
    }) {
      return status !== 'trash';
    },
    RenderModal: ReorderModal
  }, [supportsPageAttributes]);
}
const useDuplicatePostAction = postType => {
  const userCanCreatePost = (0, _data.useSelect)(select => {
    return select(_coreData.store).canUser('create', {
      kind: 'postType',
      name: postType
    });
  }, [postType]);
  return (0, _element.useMemo)(() => userCanCreatePost && {
    id: 'duplicate-post',
    label: (0, _i18n._x)('Duplicate', 'action label'),
    isEligible({
      status
    }) {
      return status !== 'trash';
    },
    RenderModal: ({
      items,
      closeModal,
      onActionPerformed
    }) => {
      const [item, setItem] = (0, _element.useState)({
        ...items[0],
        title: (0, _i18n.sprintf)( /* translators: %s: Existing template title */
        (0, _i18n.__)('%s (Copy)'), (0, _utils.getItemTitle)(items[0]))
      });
      const [isCreatingPage, setIsCreatingPage] = (0, _element.useState)(false);
      const {
        saveEntityRecord
      } = (0, _data.useDispatch)(_coreData.store);
      const {
        createSuccessNotice,
        createErrorNotice
      } = (0, _data.useDispatch)(_notices.store);
      async function createPage(event) {
        event.preventDefault();
        if (isCreatingPage) {
          return;
        }
        const newItemOject = {
          status: 'draft',
          title: item.title,
          slug: item.title || (0, _i18n.__)('No title'),
          comment_status: item.comment_status,
          content: typeof item.content === 'string' ? item.content : item.content.raw,
          excerpt: item.excerpt.raw,
          meta: item.meta,
          parent: item.parent,
          password: item.password,
          template: item.template,
          format: item.format,
          featured_media: item.featured_media,
          menu_order: item.menu_order,
          ping_status: item.ping_status
        };
        const assignablePropertiesPrefix = 'wp:action-assign-';
        // Get all the properties that the current user is able to assign normally author, categories, tags,
        // and custom taxonomies.
        const assignableProperties = Object.keys(item?._links || {}).filter(property => property.startsWith(assignablePropertiesPrefix)).map(property => property.slice(assignablePropertiesPrefix.length));
        assignableProperties.forEach(property => {
          if (item[property]) {
            newItemOject[property] = item[property];
          }
        });
        setIsCreatingPage(true);
        try {
          const newItem = await saveEntityRecord('postType', item.type, newItemOject, {
            throwOnError: true
          });
          createSuccessNotice((0, _i18n.sprintf)(
          // translators: %s: Title of the created template e.g: "Category".
          (0, _i18n.__)('"%s" successfully created.'), (0, _htmlEntities.decodeEntities)(newItem.title?.rendered || item.title)), {
            id: 'duplicate-post-action',
            type: 'snackbar'
          });
          if (onActionPerformed) {
            onActionPerformed([newItem]);
          }
        } catch (error) {
          const errorMessage = error.message && error.code !== 'unknown_error' ? error.message : (0, _i18n.__)('An error occurred while duplicating the page.');
          createErrorNotice(errorMessage, {
            type: 'snackbar'
          });
        } finally {
          setIsCreatingPage(false);
          closeModal();
        }
      }
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("form", {
        onSubmit: createPage,
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalVStack, {
          spacing: 3,
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_dataviews.DataForm, {
            data: item,
            fields: fields,
            form: formDuplicateAction,
            onChange: setItem
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalHStack, {
            spacing: 2,
            justify: "end",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Button, {
              variant: "tertiary",
              onClick: closeModal,
              __next40pxDefaultSize: true,
              children: (0, _i18n.__)('Cancel')
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Button, {
              variant: "primary",
              type: "submit",
              isBusy: isCreatingPage,
              "aria-disabled": isCreatingPage,
              __next40pxDefaultSize: true,
              children: (0, _i18n._x)('Duplicate', 'action label')
            })]
          })]
        })
      });
    }
  }, [userCanCreatePost]);
};
const duplicatePatternAction = exports.duplicatePatternAction = {
  id: 'duplicate-pattern',
  label: (0, _i18n._x)('Duplicate', 'action label'),
  isEligible: item => item.type !== _constants.TEMPLATE_PART_POST_TYPE,
  modalHeader: (0, _i18n._x)('Duplicate pattern', 'action label'),
  RenderModal: ({
    items,
    closeModal
  }) => {
    const [item] = items;
    const duplicatedProps = useDuplicatePatternProps({
      pattern: item,
      onSuccess: () => closeModal()
    });
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(CreatePatternModalContents, {
      onClose: closeModal,
      confirmLabel: (0, _i18n._x)('Duplicate', 'action label'),
      ...duplicatedProps
    });
  }
};
const duplicateTemplatePartAction = exports.duplicateTemplatePartAction = {
  id: 'duplicate-template-part',
  label: (0, _i18n._x)('Duplicate', 'action label'),
  isEligible: item => item.type === _constants.TEMPLATE_PART_POST_TYPE,
  modalHeader: (0, _i18n._x)('Duplicate template part', 'action label'),
  RenderModal: ({
    items,
    closeModal
  }) => {
    const [item] = items;
    const blocks = (0, _element.useMemo)(() => {
      var _item$blocks;
      return (_item$blocks = item.blocks) !== null && _item$blocks !== void 0 ? _item$blocks : (0, _blocks.parse)(typeof item.content === 'string' ? item.content : item.content.raw, {
        __unstableSkipMigrationLogs: true
      });
    }, [item.content, item.blocks]);
    const {
      createSuccessNotice
    } = (0, _data.useDispatch)(_notices.store);
    function onTemplatePartSuccess() {
      createSuccessNotice((0, _i18n.sprintf)(
      // translators: %s: The new template part's title e.g. 'Call to action (copy)'.
      (0, _i18n.__)('"%s" duplicated.'), (0, _utils.getItemTitle)(item)), {
        type: 'snackbar',
        id: 'edit-site-patterns-success'
      });
      closeModal();
    }
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_createTemplatePartModal.CreateTemplatePartModalContents, {
      blocks: blocks,
      defaultArea: item.area,
      defaultTitle: (0, _i18n.sprintf)( /* translators: %s: Existing template part title */
      (0, _i18n.__)('%s (Copy)'), (0, _utils.getItemTitle)(item)),
      onCreate: onTemplatePartSuccess,
      onError: closeModal,
      confirmLabel: (0, _i18n._x)('Duplicate', 'action label')
    });
  }
};
function usePostActions({
  postType,
  onActionPerformed,
  context
}) {
  const {
    defaultActions,
    postTypeObject,
    userCanCreatePostType
  } = (0, _data.useSelect)(select => {
    const {
      getPostType,
      canUser
    } = select(_coreData.store);
    const {
      getEntityActions
    } = (0, _lockUnlock.unlock)(select(_store.store));
    return {
      postTypeObject: getPostType(postType),
      defaultActions: getEntityActions('postType', postType),
      userCanCreatePostType: canUser('create', {
        kind: 'postType',
        name: postType
      })
    };
  }, [postType]);
  const {
    registerPostTypeActions
  } = (0, _lockUnlock.unlock)((0, _data.useDispatch)(_store.store));
  (0, _element.useEffect)(() => {
    registerPostTypeActions(postType);
  }, [registerPostTypeActions, postType]);
  const duplicatePostAction = useDuplicatePostAction(postType);
  const reorderPagesAction = useReorderPagesAction(postType);
  const isTemplateOrTemplatePart = [_constants.TEMPLATE_POST_TYPE, _constants.TEMPLATE_PART_POST_TYPE].includes(postType);
  const isPattern = postType === _constants.PATTERN_POST_TYPE;
  const isLoaded = !!postTypeObject;
  const supportsRevisions = !!postTypeObject?.supports?.revisions;
  const supportsTitle = !!postTypeObject?.supports?.title;
  return (0, _element.useMemo)(() => {
    if (!isLoaded) {
      return [];
    }
    let actions = [postTypeObject?.viewable && viewPostAction, supportsRevisions && postRevisionsAction, globalThis.IS_GUTENBERG_PLUGIN ? !isTemplateOrTemplatePart && !isPattern && duplicatePostAction : false, isTemplateOrTemplatePart && userCanCreatePostType && duplicateTemplatePartAction, isPattern && userCanCreatePostType && duplicatePatternAction, supportsTitle && renamePostAction, reorderPagesAction, ...defaultActions].filter(Boolean);
    // Filter actions based on provided context. If not provided
    // all actions are returned. We'll have a single entry for getting the actions
    // and the consumer should provide the context to filter the actions, if needed.
    // Actions should also provide the `context` they support, if it's specific, to
    // compare with the provided context to get all the actions.
    // Right now the only supported context is `list`.
    actions = actions.filter(action => {
      if (!action.context) {
        return true;
      }
      return action.context === context;
    });
    if (onActionPerformed) {
      for (let i = 0; i < actions.length; ++i) {
        if (actions[i].callback) {
          const existingCallback = actions[i].callback;
          actions[i] = {
            ...actions[i],
            callback: (items, argsObject) => {
              existingCallback(items, {
                ...argsObject,
                onActionPerformed: _items => {
                  if (argsObject?.onActionPerformed) {
                    argsObject.onActionPerformed(_items);
                  }
                  onActionPerformed(actions[i].id, _items);
                }
              });
            }
          };
        }
        if (actions[i].RenderModal) {
          const ExistingRenderModal = actions[i].RenderModal;
          actions[i] = {
            ...actions[i],
            RenderModal: props => {
              return /*#__PURE__*/(0, _jsxRuntime.jsx)(ExistingRenderModal, {
                ...props,
                onActionPerformed: _items => {
                  if (props.onActionPerformed) {
                    props.onActionPerformed(_items);
                  }
                  onActionPerformed(actions[i].id, _items);
                }
              });
            }
          };
        }
      }
    }
    return actions;
  }, [defaultActions, userCanCreatePostType, isTemplateOrTemplatePart, isPattern, postTypeObject?.viewable, duplicatePostAction, reorderPagesAction, onActionPerformed, isLoaded, supportsRevisions, supportsTitle, context]);
}
//# sourceMappingURL=actions.js.map