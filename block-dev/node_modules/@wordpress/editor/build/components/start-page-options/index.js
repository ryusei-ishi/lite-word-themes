"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = StartPageOptions;
var _components = require("@wordpress/components");
var _i18n = require("@wordpress/i18n");
var _element = require("@wordpress/element");
var _blockEditor = require("@wordpress/block-editor");
var _data = require("@wordpress/data");
var _compose = require("@wordpress/compose");
var _coreData = require("@wordpress/core-data");
var _blocks = require("@wordpress/blocks");
var _store = require("../../store");
var _constants = require("../../store/constants");
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function useStartPatterns() {
  // A pattern is a start pattern if it includes 'core/post-content' in its blockTypes,
  // and it has no postTypes declared and the current post type is page or if
  // the current post type is part of the postTypes declared.
  const {
    blockPatternsWithPostContentBlockType,
    postType
  } = (0, _data.useSelect)(select => {
    const {
      getPatternsByBlockTypes,
      getBlocksByName
    } = select(_blockEditor.store);
    const {
      getCurrentPostType,
      getRenderingMode
    } = select(_store.store);
    const rootClientId = getRenderingMode() === 'post-only' ? '' : getBlocksByName('core/post-content')?.[0];
    return {
      blockPatternsWithPostContentBlockType: getPatternsByBlockTypes('core/post-content', rootClientId),
      postType: getCurrentPostType()
    };
  }, []);
  return (0, _element.useMemo)(() => {
    // filter patterns without postTypes declared if the current postType is page
    // or patterns that declare the current postType in its post type array.
    return blockPatternsWithPostContentBlockType.filter(pattern => {
      return postType === 'page' && !pattern.postTypes || Array.isArray(pattern.postTypes) && pattern.postTypes.includes(postType);
    });
  }, [postType, blockPatternsWithPostContentBlockType]);
}
function PatternSelection({
  blockPatterns,
  onChoosePattern
}) {
  const shownBlockPatterns = (0, _compose.useAsyncList)(blockPatterns);
  const {
    editEntityRecord
  } = (0, _data.useDispatch)(_coreData.store);
  const {
    postType,
    postId
  } = (0, _data.useSelect)(select => {
    const {
      getCurrentPostType,
      getCurrentPostId
    } = select(_store.store);
    return {
      postType: getCurrentPostType(),
      postId: getCurrentPostId()
    };
  }, []);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_blockEditor.__experimentalBlockPatternsList, {
    blockPatterns: blockPatterns,
    shownPatterns: shownBlockPatterns,
    onClickPattern: (_pattern, blocks) => {
      editEntityRecord('postType', postType, postId, {
        blocks,
        content: ({
          blocks: blocksForSerialization = []
        }) => (0, _blocks.__unstableSerializeAndClean)(blocksForSerialization)
      });
      onChoosePattern();
    }
  });
}
function StartPageOptionsModal({
  onClose
}) {
  const startPatterns = useStartPatterns();
  const hasStartPattern = startPatterns.length > 0;
  if (!hasStartPattern) {
    return null;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.Modal, {
    title: (0, _i18n.__)('Choose a pattern'),
    isFullScreen: true,
    onRequestClose: onClose,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "editor-start-page-options__modal-content",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(PatternSelection, {
        blockPatterns: startPatterns,
        onChoosePattern: onClose
      })
    })
  });
}
function StartPageOptions() {
  const [isClosed, setIsClosed] = (0, _element.useState)(false);
  const {
    shouldEnableModal,
    postType,
    postId
  } = (0, _data.useSelect)(select => {
    const {
      isEditedPostDirty,
      isEditedPostEmpty,
      getCurrentPostType,
      getCurrentPostId
    } = select(_store.store);
    const _postType = getCurrentPostType();
    return {
      shouldEnableModal: !isEditedPostDirty() && isEditedPostEmpty() && _constants.TEMPLATE_POST_TYPE !== _postType,
      postType: _postType,
      postId: getCurrentPostId()
    };
  }, []);
  (0, _element.useEffect)(() => {
    // Should reset the modal state when navigating to a new page/post.
    setIsClosed(false);
  }, [postType, postId]);
  if (!shouldEnableModal || isClosed) {
    return null;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(StartPageOptionsModal, {
    onClose: () => setIsClosed(true)
  });
}
//# sourceMappingURL=index.js.map