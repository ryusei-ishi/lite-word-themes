"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BlockBindingsPanel = void 0;
var _i18n = require("@wordpress/i18n");
var _blocks = require("@wordpress/blocks");
var _components = require("@wordpress/components");
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _compose = require("@wordpress/compose");
var _useBindingsAttributes = require("../hooks/use-bindings-attributes");
var _store = require("../store");
var _lockUnlock = require("../lock-unlock");
var _inspectorControls = _interopRequireDefault(require("../components/inspector-controls"));
var _blockContext = _interopRequireDefault(require("../components/block-context"));
var _jsxRuntime = require("react/jsx-runtime");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const {
  DropdownMenuV2: DropdownMenu,
  DropdownMenuGroupV2: DropdownMenuGroup,
  DropdownMenuRadioItemV2: DropdownMenuRadioItem,
  DropdownMenuItemLabelV2: DropdownMenuItemLabel,
  DropdownMenuItemHelpTextV2: DropdownMenuItemHelpText,
  DropdownMenuSeparatorV2: DropdownMenuSeparator
} = (0, _lockUnlock.unlock)(_components.privateApis);
const useToolsPanelDropdownMenuProps = () => {
  const isMobile = (0, _compose.useViewportMatch)('medium', '<');
  return !isMobile ? {
    popoverProps: {
      placement: 'left-start',
      // For non-mobile, inner sidebar width (248px) - button width (24px) - border (1px) + padding (16px) + spacing (20px)
      offset: 259
    }
  } : {};
};
function BlockBindingsPanelDropdown({
  fieldsList,
  addConnection,
  attribute,
  binding
}) {
  const currentKey = binding?.args?.key;
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: Object.entries(fieldsList).map(([label, fields], i) => /*#__PURE__*/(0, _jsxRuntime.jsxs)(_element.Fragment, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(DropdownMenuGroup, {
        children: [Object.keys(fieldsList).length > 1 && /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalText, {
          className: "block-editor-bindings__source-label",
          upperCase: true,
          variant: "muted",
          "aria-hidden": true,
          children: label
        }), Object.entries(fields).map(([key, value]) => /*#__PURE__*/(0, _jsxRuntime.jsxs)(DropdownMenuRadioItem, {
          onChange: () => addConnection(key, attribute),
          name: attribute + '-binding',
          value: key,
          checked: key === currentKey,
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(DropdownMenuItemLabel, {
            children: key
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)(DropdownMenuItemHelpText, {
            children: value
          })]
        }, key))]
      }), i !== Object.keys(fieldsList).length - 1 && /*#__PURE__*/(0, _jsxRuntime.jsx)(DropdownMenuSeparator, {})]
    }, label))
  });
}
function BlockBindingsAttribute({
  attribute,
  binding
}) {
  const {
    source: sourceName,
    args
  } = binding || {};
  const sourceProps = (0, _lockUnlock.unlock)(_blocks.privateApis).getBlockBindingsSource(sourceName);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalVStack, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalTruncate, {
      children: attribute
    }), !!binding && /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalText, {
      variant: "muted",
      className: "block-editor-bindings__item-explanation",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalTruncate, {
        children: args?.key || sourceProps?.label || sourceName
      })
    })]
  });
}
function ReadOnlyBlockBindingsPanelItems({
  bindings
}) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: Object.entries(bindings).map(([attribute, binding]) => /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalItem, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(BlockBindingsAttribute, {
        attribute: attribute,
        binding: binding
      })
    }, attribute))
  });
}
function EditableBlockBindingsPanelItems({
  attributes,
  bindings,
  fieldsList,
  addConnection,
  removeConnection
}) {
  const isMobile = (0, _compose.useViewportMatch)('medium', '<');
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: attributes.map(attribute => {
      const binding = bindings[attribute];
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalToolsPanelItem, {
        hasValue: () => !!binding,
        label: attribute,
        onDeselect: () => {
          removeConnection(attribute);
        },
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(DropdownMenu, {
          placement: isMobile ? 'bottom-start' : 'left-start',
          gutter: isMobile ? 8 : 36,
          className: "block-editor-bindings__popover",
          trigger: /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalItem, {
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(BlockBindingsAttribute, {
              attribute: attribute,
              binding: binding
            })
          }),
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(BlockBindingsPanelDropdown, {
            fieldsList: fieldsList,
            addConnection: addConnection,
            attribute: attribute,
            binding: binding
          })
        })
      }, attribute);
    })
  });
}
const BlockBindingsPanel = ({
  name,
  metadata
}) => {
  const registry = (0, _data.useRegistry)();
  const blockContext = (0, _element.useContext)(_blockContext.default);
  const {
    bindings
  } = metadata || {};
  const bindableAttributes = (0, _useBindingsAttributes.getBindableAttributes)(name);
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const filteredBindings = {
    ...bindings
  };
  Object.keys(filteredBindings).forEach(key => {
    if (!(0, _useBindingsAttributes.canBindAttribute)(name, key) || filteredBindings[key].source === 'core/pattern-overrides') {
      delete filteredBindings[key];
    }
  });
  const {
    updateBlockAttributes
  } = (0, _data.useDispatch)(_store.store);
  const {
    _id
  } = (0, _data.useSelect)(select => {
    const {
      getSelectedBlockClientId
    } = select(_store.store);
    return {
      _id: getSelectedBlockClientId()
    };
  }, []);
  if (!bindableAttributes || bindableAttributes.length === 0) {
    return null;
  }
  const removeAllConnections = () => {
    const newMetadata = {
      ...metadata
    };
    delete newMetadata.bindings;
    updateBlockAttributes(_id, {
      metadata: Object.keys(newMetadata).length === 0 ? undefined : newMetadata
    });
  };
  const addConnection = (value, attribute) => {
    // Assuming the block expects a flat structure for its metadata attribute
    const newMetadata = {
      ...metadata,
      // Adjust this according to the actual structure expected by your block
      bindings: {
        ...metadata?.bindings,
        [attribute]: {
          source: 'core/post-meta',
          args: {
            key: value
          }
        }
      }
    };
    // Update the block's attributes with the new metadata
    updateBlockAttributes(_id, {
      metadata: newMetadata
    });
  };
  const removeConnection = key => {
    const newMetadata = {
      ...metadata
    };
    if (!newMetadata.bindings) {
      return;
    }
    delete newMetadata.bindings[key];
    if (Object.keys(newMetadata.bindings).length === 0) {
      delete newMetadata.bindings;
    }
    updateBlockAttributes(_id, {
      metadata: Object.keys(newMetadata).length === 0 ? undefined : newMetadata
    });
  };
  const fieldsList = {};
  const {
    getBlockBindingsSources
  } = (0, _lockUnlock.unlock)(_blocks.privateApis);
  const registeredSources = getBlockBindingsSources();
  Object.values(registeredSources).forEach(({
    getFieldsList,
    label,
    usesContext
  }) => {
    if (getFieldsList) {
      // Populate context.
      const context = {};
      if (usesContext?.length) {
        for (const key of usesContext) {
          context[key] = blockContext[key];
        }
      }
      const sourceList = getFieldsList({
        registry,
        context
      });
      // Only add source if the list is not empty.
      if (sourceList) {
        fieldsList[label] = {
          ...sourceList
        };
      }
    }
  });
  // Remove empty sources.
  Object.entries(fieldsList).forEach(([key, value]) => {
    if (!Object.keys(value).length) {
      delete fieldsList[key];
    }
  });

  // Lock the UI when the experiment is not enabled or there are no fields to connect to.
  const readOnly = !window.__experimentalBlockBindingsUI || !Object.keys(fieldsList).length;
  if (readOnly && Object.keys(filteredBindings).length === 0) {
    return null;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_inspectorControls.default, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_components.__experimentalToolsPanel, {
      label: (0, _i18n.__)('Attributes'),
      resetAll: () => {
        removeAllConnections();
      },
      dropdownMenuProps: dropdownMenuProps,
      className: "block-editor-bindings__panel",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalItemGroup, {
        isBordered: true,
        isSeparated: true,
        children: readOnly ? /*#__PURE__*/(0, _jsxRuntime.jsx)(ReadOnlyBlockBindingsPanelItems, {
          bindings: filteredBindings
        }) : /*#__PURE__*/(0, _jsxRuntime.jsx)(EditableBlockBindingsPanelItems, {
          attributes: bindableAttributes,
          bindings: filteredBindings,
          fieldsList: fieldsList,
          addConnection: addConnection,
          removeConnection: removeConnection
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_components.__experimentalText, {
        variant: "muted",
        children: (0, _i18n.__)('Attributes connected to various sources.')
      })]
    })
  });
};
exports.BlockBindingsPanel = BlockBindingsPanel;
var _default = exports.default = {
  edit: BlockBindingsPanel,
  attributeKeys: ['metadata'],
  hasSupport() {
    return true;
  }
};
//# sourceMappingURL=block-bindings.js.map